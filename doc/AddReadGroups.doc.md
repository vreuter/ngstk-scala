# `AddReadGroups`

## Example
**Command**:
```
java -cp $NGSTK ngstk.AddReadGroups -M /path/to/sample-sheet.tsv -F /path/to/fastqs -B /path/to/bams
```
**Breakdown**:
- `java` to fire up the JVM and run the program
- `-jar` to specify path to the library's JAR file
- `ngstk.AddReadGroups` specifies the program to run (`<library>.<program>`)
- `-M` specifies the path to the sample sheet file
- `-F` specifies the path to the folder with FASTQ files
- `-B` specifies the path to the folder with BAM files

## Motivation
***Read group*** is a term used, at least in Picard and probably other bioinformatics tools, to refer to a collection of sequencing reads or alignment records that come from the same sample and were sequenced in the same environment. Here "sample" means the usual sense of something like "application of a protcol to a particular pool of material from an individual," and "same environment" refer to the *combination of **flowcell** and **lane***.

Why this distinction and these definitions? The idea is to identify collections of reads/records generated by the same underlying process, and therefore with the same underyling error model. This allows things like **base call quality score reclibration** ("BQSR" in Picard) to perform more accurately, able to model different error distributions for different pools of reads. The combination of biological/technical sample and flowcell+lane captures error sources that may differ either by prep or by instrument.

## Overview
- **What**: a program to add read group information to alignment records in BAM files, after the alignment's been done, without needing to repeat the aligment (which typically is computationally costly). 
*"Read group"* is a term used, at least in Picard, to denote a set of sequence reads that come from the same sample and were sequenced in the same lane.
- **Why**: some Picard tools (and probably other bioinformatics tools) won't work without read group information in an alignment file.
- **How**: This program parses--from the sample sheet and associated FASTQ files for a set of samples--the pieces of information necessary to define read groups. This is then added to each BAM file as appropriate.
- **Where**: read group information is in a SAM/BAM header (often multiple groups per)
- **When**: this aims to address cases in which read group information wasn't added during the initial alignment step, but it later becomes apparently necessary or useful to have for some part of analysis. This could be especially useful for public data, when we can't modify the procedure that's generating the alignment data.

## Assumptions and Limitations
These are assumptions that I made in initially writing this program, and/or traits of the set of samples I was working with, that I may have inadvertently "baked in" to the program as assumptions that could be relaxed by generalizing small bits of code, adding parameter hooks.
### General
- Sample names prefixed with `Sample_`
### Structural (filesystem)
- All BAMs in a single folder; currently this is a major limitation since it's not our default layout on the cluster, but it can be overcome with clever symlinking. It shouldn't be problematic at  all to accommodate the "normal" cluster layout, though it's desirable to retain the current model since it's a likely structure for downloaded public data.
### Within files
- `.bam` extension on BAM files
- `.fastq` extension on FASTQ files
- Sample name embedded in filename both for BAM and for FASTQ
- Lane number embedded as `L00<x>` in FASTQ name
- Illumina sequencing data (relevant for parsing read name fields from first FASTQ record and from each BAM record)

**Sample sheet** 
1. Tab-delimited/-separated values in the sample sheet
2. `Sample Name` as the relevant column name for the sample name info in the sheet
3. `Machine Manufacturer`: the name of the column from which to get platform name
4. `BarcodeIdx`: the name of the column for library/barcode info for each sample; may've needed to split this to extract simple integer value

## Rationale
- Alignment is costly (in compute resouces); why repeat it if we just need to add some metadata?
- It's easy to forget to add an option for the aligner to add read group info
- It's not always easy to remember and/or to actually check someone else's processing tool(s) before use to see that read group info will be added during alignment.
- We may well get aligned BAMs and sufficient metadata from public data, and be able to use this program to augment such data with read group info as needed.
- Most of the sequencing data we work with is Illumina (?), and we have a very systematic filesystem layout for sequencing data on the cluster. We can use that knowledge and system to write programs that are relatively simple but powerful, as the structure allows use to do interesting things with comparatively little case accounting in our programs.

## Implementation detail
1. Parse sample sheet, extracting the relevant info (sequencing platform name, and sample names). This provides sample name + platform name + library/barcode ID tuples.
2. Find FASTQ files, getting lane number from the file name and instrument number (flowcell ID) by opening each FASTQ and "peeking" at the first record, parsing flowcell ID from the read name. Critically, this *assumes all reads in a single file are from a single flowcell*, at least for FASTQs. This yields a collection of flowcell + lane pairs for each sample.
3. With sample name mapped both to platform + library/barcode ID, and to (flowcell, lane) pairs, we have sufficient info to define 5 main fields for read group (`RG`) tag in BAM header and records.
4. Construct the read group data instances. 
5. For each BAM file, infer sample name from file name, then grab the relevant records (platform + barcode/library, and the flowcell + lane pairs), which are stored as read group data instances.
5. Based on a BAMs sample name, add a header with read groups for all the associated data instances; write this header.
6. For each record in a BAM, parse the query name as read name, using that to get flowcell ID and lane number (as in Illumina FASTQ read naming). This should correspond to exactly 1 of the read group data instances for the current BAM's sample. Add this to the record and write it to the active output file.


## Future directions
- Add [read group intermediate checkpoint](https://github.com/vreuter/ngstk-scala/issues/3) that a user could toggle to indicate that they want to see the read group data that would be added, before committing to to the time-intensive BAM iteration and file I/O operations.
- Support the [filesystem layout](https://github.com/vreuter/ngstk-scala/issues/4) that's more common for sequencing run data stored on Kim Lab cluster. Specifically, allow FASTQ and BAM files to be distributed among individual folders (per-sample organization) rather than aggregated into a single folder and distinguished by filename-to-sample-name correspondence (per-data-type organization).
- Support generation, and possibly execution, of [downstream commands](https://github.com/vreuter/ngstk-scala/issues/2) for common things that would want read group info, e.g. `gatk MarkDuplicatesSpark` --> `SetNmMdAndUqTags` --> base quality score recalibration (BQSR).
### More flexibility via parameterization
- Support more flexible sample name inference from filenames
- More flexibility and testing of specification of which column names from sample sheet are relevant


